# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PointInPolygonsDialog
                                 A QGIS plugin
 The plugin shows points within a boundary
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-30
        copyright            : (C) 2024 by Samuel Njoka
        email                : bsc-com_09-20@unima.ac.mw
 ***************************************************************************/
"""

import os
import logging
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
from qgis.core import (QgsVectorLayer, QgsFeature, QgsGeometry, QgsProject, QgsField, QgsDataSourceUri)
from qgis.PyQt.QtCore import QVariant

# Configure logging
logging.basicConfig(level=logging.INFO)

# Load UI
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'Point_in_polygon_analyzer_dialog_base.ui'))

class DatabaseHandler:
    """Handles database connections and data retrieval."""
    def __init__(self, db_name, user, password, host, port):
        self.db_name = db_name
        self.user = user
        self.password = password
        self.host = host
        self.port = port
        self.connection = None

    def connect(self):
        """Establish a connection to the database."""
        import psycopg2
        try:
            self.connection = psycopg2.connect(
                dbname=self.db_name,
                user=self.user,
                password=self.password,
                host=self.host,
                port=self.port
            )
            logging.info("Database connection established.")
            return True
        except Exception as e:
            QMessageBox.critical(None, "Database Connection Error", f"Could not connect to database: {str(e)}")
            logging.error(f"Database connection error: {str(e)}")
            return False

    def fetch_layer(self, table_name, geom_column='geom', layer_name=None):
        """Fetch a layer from the database."""
        if not self.connection:
            logging.warning("No database connection established.")
            return None

        uri = QgsDataSourceUri()
        uri.setConnection(self.host, self.port, self.db_name, self.user, self.password)
        uri.setDataSource("", table_name, geom_column)

        layer_name = layer_name or table_name
        layer = QgsVectorLayer(uri.uri(), layer_name, "postgres")

        if not layer.isValid():
            logging.error(f"Failed to load layer '{table_name}' from the database.")
            return None

        logging.info(f"Successfully loaded layer '{table_name}' from the database.")
        return layer


class PointInPolygonsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(PointInPolygonsDialog, self).__init__(parent)
        self.setupUi(self)

        # Connect buttons to methods
        self.btnSelectPointLayer.clicked.connect(self.select_point_layer)
        self.btnSelectPolygonLayer.clicked.connect(self.select_polygon_layer)
        self.btnAnalyze.clicked.connect(self.analyze_points_in_polygons)

        # Initialize layer variables
        self.point_layer = None
        self.polygon_layer = None
        self.db_handler = DatabaseHandler("gis_project", "postgres", "1902", "localhost", "5432")

    def select_point_layer(self):
        """Load point layer from the database or file."""
        if self.db_handler.connect():
            # Attempt to load layer from the database
            self.point_layer = self.db_handler.fetch_layer("ll_schools", "geom", "Schools Points")
        
        if not self.point_layer:
            # If database fetch fails, fallback to file selection
            file_path, _ = QFileDialog.getOpenFileName(self, "Select Point Layer", "", "Shapefile (*.shp);;GeoJSON (*.geojson);;All Files (*)")
            if file_path:
                self.point_layer = QgsVectorLayer(file_path, "Point Layer", "ogr")
        
        # Validate and update the UI
        if self.point_layer and self.point_layer.isValid():
            self.lblPointLayer.setText(self.point_layer.name())
            logging.info(f"Point layer selected: {self.point_layer.name()}")
        else:
            QMessageBox.warning(self, "Error", "Could not load point layer.")
            logging.error("Point layer loading failed.")

    def select_polygon_layer(self):
        """Load polygon layer from the database or file."""
        if self.db_handler.connect():
            # Attempt to load layer from the database
            self.polygon_layer = self.db_handler.fetch_layer("areas", "geom", "Areas Polygons")
        
        if not self.polygon_layer:
            # If database fetch fails, fallback to file selection
            file_path, _ = QFileDialog.getOpenFileName(self, "Select Polygon Layer", "", "Shapefile (*.shp);;GeoJSON (*.geojson);;All Files (*)")
            if file_path:
                self.polygon_layer = QgsVectorLayer(file_path, "Polygon Layer", "ogr")
        
        # Validate and update the UI
        if self.polygon_layer and self.polygon_layer.isValid():
            self.lblPolygonLayer.setText(self.polygon_layer.name())
            logging.info(f"Polygon layer selected: {self.polygon_layer.name()}")
        else:
            QMessageBox.warning(self, "Error", "Could not load polygon layer.")
            logging.error("Polygon layer loading failed.")

    def analyze_points_in_polygons(self):
        """Analyze points within polygons and display results."""
        # Validation checks
        if not self.point_layer or not self.polygon_layer:
            QMessageBox.warning(self, "Error", "Please select both point and polygon layers.")
            logging.warning("Missing layers for analysis.")
            return

        # Ensure layers have the same CRS
        if self.point_layer.crs().authid() != self.polygon_layer.crs().authid():
            reply = QMessageBox.question(
                self, 
                "CRS Mismatch", 
                "Point and polygon layers have different coordinate systems. Do you want to proceed anyway?", 
                QMessageBox.Yes | QMessageBox.No
            )
            if reply == QMessageBox.No:
                logging.info("User chose not to proceed with different CRS.")
                return

        points_inside = []
        
        # Check if the 'polygon_id' field exists in point layer
        if 'polygon_id' not in self.point_layer.fields().names():
            self.point_layer.dataProvider().addAttributes([QgsField("polygon_id", QVariant.Int)])
            self.point_layer.updateFields()
            logging.info("Added 'polygon_id' field to point layer.")

        for point_feature in self.point_layer.getFeatures():
            point_geom = point_feature.geometry()
            is_inside = False

            for polygon_feature in self.polygon_layer.getFeatures():
                polygon_geom = polygon_feature.geometry()
                if polygon_geom.contains(point_geom):
                    is_inside = True
                    point_feature['polygon_id'] = polygon_feature.id()
                    break
            if is_inside:
                points_inside.append(point_feature)

        fields = self.point_layer.fields()
        memory_layer = QgsVectorLayer(f"Point?crs={self.point_layer.crs().authid()}", "Points Inside", "memory")
        memory_layer_data_provider = memory_layer.dataProvider()
        memory_layer_data_provider.addAttributes(fields)
        memory_layer.updateFields()

        for feature in points_inside:
            memory_layer_data_provider.addFeature(feature)
        
        QgsProject.instance().addMapLayer(memory_layer)

        total_points = sum(1 for _ in self.point_layer.getFeatures())
        results_text = (
            f"Total Points: {total_points}\n"
            f"Points Inside Polygons: {len(points_inside)}"
        )
        
        QMessageBox.information(self, "Analysis Results", results_text)
        logging.info("Analysis completed and results displayed.")
